import * as vscode from "vscode";

import { getNodeValue, Node } from "jsonc-parser/lib/esm/main";

import {
  CANNOT_PARSE_FILE_ERROR,
  CANNOT_READ_FILE_ERROR,
  CONFIG_SECTION,
  IMPORT_INTO_PROPERTY,
  IMPORTS_MISMATCH_ERROR,
  IMPORTS_PROPERTY,
  NO_CLOSING_COMMENT_ERROR,
} from "./constants";
import {
  commaInsertionOffset,
  convertRange,
  getJsonImports,
  isJson,
  parseJsonConfig,
} from "./languages/json";
import { isNickel, loadNickelFile } from "./languages/nickel";
import {
  joinMixed,
  readFile,
  registerForAllSettingsValues,
  writeFile,
} from "./utils";
import { findNodeAtLocation } from "jsonc-parser/lib/esm/main";

const GEN_START_COMMENT =
  "// #region Generated by https://github.com/71/computed-settings\n";
const GEN_END_COMMENT =
  "// #endregion Generated by https://github.com/71/computed-settings\n";
const GEN_START_COMMENT_RE =
  /^ *\/\/ #region Generated by https:\/\/github\.com\/71\/computed-settings\n/m;
const GEN_END_COMMENT_RE =
  /^ *\/\/ #endregion Generated by https:\/\/github\.com\/71\/computed-settings\n/m;

/**
 * Registers the import system for configurations, i.e. handling of the
 * `imports` and `importInto` properties.
 */
export function registerImportSystem(context: vscode.ExtensionContext) {
  const diagnosticCollection = vscode.languages.createDiagnosticCollection(
    "settings-imports",
  );

  context.subscriptions.push(
    diagnosticCollection,
    {
      dispose() {
        ConfigurationFile.disposeAll();
      },
    },
  );

  /**
   * A configuration file in the graph of imports.
   */
  class ConfigurationFile implements vscode.Disposable {
    public static readonly files = new Map<string, ConfigurationFile>();

    public static disposeAll(): void {
      for (const file of this.files.values()) {
        file.dispose();
      }

      this.files.clear();
    }

    private updateCts?: vscode.CancellationTokenSource;
    private configOrImportError?: Record<string, unknown> | unknown[] | string;

    private readonly additionalDiagnostics: vscode.Diagnostic[] = [];
    private readonly importDiagnostics: vscode.Diagnostic[] = [];

    /**
     * Files imported from (using `imports`) or into (using `importInto`) this
     * file.
     */
    private readonly imports: (readonly [ConfigurationFile, vscode.Range])[] =
      [];

    /**
     * Files that import this file, either directly or indirectly.
     */
    private readonly importers: Set<ConfigurationFile> = new Set();

    private readonly fileWatcher = vscode.workspace.createFileSystemWatcher(
      this.uri.fsPath,
      true,
      false,
      false,
    );

    private get diagnostics(): readonly vscode.Diagnostic[] {
      if (
        this.importDiagnostics.length > 0 &&
        this.additionalDiagnostics.length > 0
      ) {
        return [...this.importDiagnostics, ...this.additionalDiagnostics];
      }

      return this.importDiagnostics.length > 0
        ? this.importDiagnostics
        : this.additionalDiagnostics;
    }

    private get isWorkspaceFile(): boolean {
      return this.uri.path.endsWith(".code-workspace");
    }

    private get hasIndirectImports(): boolean {
      return this.writeTo && !this.isRootFile;
    }

    public hasImports(): boolean {
      return this.imports.length > 0;
    }

    private constructor(
      /**
       * The URI of the file to read from (and write to, if {@link writeTo} is
       * true).
       */
      public readonly uri: vscode.Uri,
      /**
       * Whether the file is a "root" configuration file, i.e. a file observed
       * by VS Code and which should always be watched, like `settings.json` in
       * the user's profile or in the `.vscode` directory of a workspace.
       */
      public readonly isRootFile: boolean,
      /**
       * Whether the file should be written to, instead of propagating
       * configurations to importers.
       */
      public readonly writeTo: boolean,
    ) {
      console.assert(isRootFile ? writeTo : true);

      if (!isRootFile) {
        this.fileWatcher.onDidChange(() => this.handleFileChange());
        this.fileWatcher.onDidDelete(() =>
          this.setImportError(CANNOT_READ_FILE_ERROR)
        );

        this.handleFileChange();
      }
    }

    private static getOrCreate(
      uri: vscode.Uri,
      isRootFile: boolean,
      writeTo: boolean,
    ): ConfigurationFile {
      const uriString = uri.fsPath;
      let result = this.files.get(uriString);

      if (result === undefined) {
        this.files.set(
          uriString,
          result = new ConfigurationFile(uri, isRootFile, writeTo),
        );
      } else {
        // TODO: handle mismatch
      }

      return result;
    }

    public static root(uri: vscode.Uri): ConfigurationFile {
      return this.getOrCreate(uri, true, true);
    }

    public static writtenTo(uri: vscode.Uri): ConfigurationFile {
      return this.getOrCreate(uri, false, true);
    }

    public static imported(uri: vscode.Uri): ConfigurationFile {
      return this.getOrCreate(uri, false, false);
    }

    /**
     * Notifies imports that the current configuration has been disposed,
     * disposing them if they are no longer useful.
     */
    public dispose() {
      ConfigurationFile.files.delete(this.uri.fsPath);

      this.fileWatcher.dispose();

      diagnosticCollection.delete(this.uri);

      for (const [importee] of this.imports) {
        importee.importers.delete(this);

        if (importee.importers.size === 0 && !importee.isRootFile) {
          importee.dispose();
        }
      }
    }

    /**
     * Performs the given action asynchronously in the background; if this
     * function is called again before the completion of the previous promise,
     * said previous promise will be cancelled.
     */
    private withCancellation(
      action: (token: vscode.CancellationToken) => Promise<void>,
    ): void {
      if (this.updateCts !== undefined) {
        this.updateCts.cancel();
        this.updateCts.dispose();
      }

      this.updateCts = new vscode.CancellationTokenSource();

      action(this.updateCts.token);
    }

    // #region Diagnostics

    /**
     * Refreshes diagnostics shown in VS Code, recomputing import-related
     * diagnostics.
     */
    private refreshDiagnostics(): void {
      const diagnostics = this.importDiagnostics;

      diagnostics.length = 0;

      for (
        const [{ configOrImportError: importError }, importRange] of this
          .imports
      ) {
        if (typeof importError !== "string") {
          continue;
        }

        diagnostics.push(
          new vscode.Diagnostic(
            importRange,
            importError,
            vscode.DiagnosticSeverity.Error,
          ),
        );
      }

      diagnosticCollection.set(this.uri, this.diagnostics);
    }

    /**
     * Sets the diagnostics associated with the file.
     */
    private setDiagnostics(diagnostics: readonly vscode.Diagnostic[]): void {
      this.additionalDiagnostics.splice(
        0,
        this.additionalDiagnostics.length,
        ...diagnostics,
      );

      diagnosticCollection.set(this.uri, this.diagnostics);
    }

    /**
     * Sets an error that is shown as a diagnostic where the current file is
     * imported.
     */
    private setImportError(error: string): void {
      if (this.configOrImportError === error) {
        return;
      }

      // Clear diagnostics for current file.
      this.additionalDiagnostics.length = 0;
      this.importDiagnostics.length = 0;

      diagnosticCollection.delete(this.uri);

      // Set error and notify importers.
      this.configOrImportError = error;

      for (const importer of this.importers) {
        importer.refreshDiagnostics();
      }
    }

    /**
     * Clears the current import error.
     */
    private clearImportError(): void {
      if (this.configOrImportError === undefined) {
        return;
      }

      this.configOrImportError = undefined;

      for (const importer of this.importers) {
        importer.refreshDiagnostics();
      }
    }

    // #endregion Diagnostics

    // #region Shared utilities

    /**
     * Resolves a relative import path.
     */
    private resolve(importPath: string): vscode.Uri {
      return joinMixed(this.uri, "..", importPath);
    }

    private mergeImportedConfigs(): Record<string, unknown> {
      if (typeof this.configOrImportError === "string") {
        return {};
      }

      const configsToMerge = this.imports.map(([file]) =>
        file.mergeImportedConfigs()
      );

      if (Array.isArray(this.configOrImportError)) {
        // TODO: report error
        return {};
      }

      if (this.configOrImportError !== undefined) {
        configsToMerge.push(this.configOrImportError);
      }

      return mergeRootObjects(configsToMerge);
    }

    private mergeImportedArrayConfigs(): unknown[] {
      if (typeof this.configOrImportError === "string") {
        return [];
      }

      const configsToMerge = this.imports.map(([file]) =>
        file.mergeImportedArrayConfigs()
      );

      if (Array.isArray(this.configOrImportError)) {
        configsToMerge.push(this.configOrImportError);
      } else if (this.configOrImportError !== undefined) {
        configsToMerge.push([this.configOrImportError]);
      }

      return mergeRootArrays(configsToMerge);
    }

    /**
     * Returns whether the given imports are equal to the current ones.
     */
    public importsEqual(imports: readonly string[]): boolean {
      const current = this.imports;

      return current.length === imports.length &&
        imports.every((importPath, i) =>
          this.resolve(importPath).toString() === current[i][0].uri.toString()
        );
    }

    // #endregion

    // #region Responding to changes

    /**
     * Handles a change in the current file.
     */
    private handleFileChange(): void {
      this.withCancellation(async (token) => {
        if (isJson(this.uri)) {
          // Parse file.
          const parsed = await this.readAndParseJsonFile(token);

          if (parsed === undefined) {
            return;
          }

          const [contents, fileRoot, diagnostics] = parsed;
          const root = this.isWorkspaceFile
            ? findNodeAtLocation(fileRoot, ["settings"])!
            : fileRoot;
          const json = getNodeValue(fileRoot);

          // Handle self imports.
          if (IMPORTS_PROPERTY in json) {
            delete json[IMPORTS_PROPERTY];

            this.updateImportsOnlyFromJson(
              contents,
              findNodeAtLocation(root, [IMPORTS_PROPERTY])!,
              undefined,
              diagnostics,
            );
          }

          if (IMPORT_INTO_PROPERTY in json) {
            delete json[IMPORT_INTO_PROPERTY];

            // TODO: handle
          }

          // Update config.
          this.configOrImportError = json;
        } else if (isNickel(this.uri)) {
          const imports: [string, vscode.Range][] = [];

          try {
            this.configOrImportError = await loadNickelFile(
              context,
              this.uri,
              (uri, range) => {
                imports.push([uri.toString(), range]);
              },
              token,
            );
          } catch (e) {
            this.configOrImportError = (e as Error).message;
          }

          this.updateImportsOnly(
            imports,
            undefined,
            [],
            new vscode.Range(0, 0, 0, 0),
          );
        } else {
          this.setImportError("unsupported file");

          return;
        }

        // Notify importers.
        if (!this.writeTo) {
          this.handleImportedFileChange(new Set());
        }
      });
    }

    /**
     * Handles a change in an imported file.
     */
    private handleImportedFileChange(impacted: Set<ConfigurationFile>): void {
      if (!this.writeTo) {
        // Propagate changes up.
        for (const importer of this.importers) {
          importer.handleImportedFileChange(impacted);
        }

        return;
      }

      const impactedBefore = impacted.size;

      if (impacted.add(this).size === impactedBefore) {
        // File was already notified.
        return;
      }

      this.withCancellation(async (token) => {
        const parsed = await this.readAndParseJsonFile(token);

        if (parsed === undefined) {
          return;
        }

        await this.writeConfiguration(
          ...parsed,
          new vscode.Range(0, 0, 0, 0),
          token,
        );
      });
    }

    // #endregion

    // #region Writing to files

    /**
     * Updates the imports of the configuration; if the set of imports changed,
     * the configuration will be updated.
     */
    public updateImports(
      imports: readonly string[],
      importer?: ConfigurationFile,
      importIntoPath?: string,
    ): void {
      console.assert(this.writeTo);

      if (this.importsEqual(imports)) {
        return;
      }

      this.withCancellation(async (token) => {
        await this.updateImportsAndWriteConfiguration(
          imports,
          importer,
          importIntoPath,
          token,
        );
      });
    }

    /**
     * Implementation of {@link updateImports()} with no race protection.
     */
    private async updateImportsAndWriteConfiguration(
      imports: readonly string[],
      importer: ConfigurationFile | undefined,
      importIntoPath: string | undefined,
      token: vscode.CancellationToken,
    ): Promise<void> {
      // Parse file.
      const parsed = await (importer ?? this).readAndParseJsonFile(token);

      if (parsed === undefined) {
        return;
      }

      const [contents, fileRoot, diagnostics] = parsed;
      const root = (importer ?? this).isWorkspaceFile
        ? findNodeAtLocation(fileRoot, ["settings"])!
        : fileRoot;

      // Find imports node.
      const importsNode = importIntoPath === undefined
        ? findNodeAtLocation(root, [IMPORTS_PROPERTY])
        : findNodeAtLocation(root, [IMPORT_INTO_PROPERTY, importIntoPath]);

      if (importsNode === undefined) {
        this.setDiagnostics([
          new vscode.Diagnostic(
            new vscode.Range(0, 0, 0, 0),
            CANNOT_PARSE_FILE_ERROR,
          ),
          ...diagnostics,
        ]);

        return;
      }

      this.updateImportsOnlyFromJson(
        contents,
        importsNode,
        imports,
        diagnostics,
      );

      // Write configuration.
      const errorRange = convertRange(
        contents,
        importsNode.offset,
        importsNode.length,
      );

      let [configContents, configRoot, configDiagnostics] = [
        contents,
        root,
        diagnostics,
      ];

      if (importer !== undefined) {
        const parsed = await this.readAndParseJsonFile(token);

        if (parsed === undefined) {
          return;
        }

        [configContents, configRoot, configDiagnostics] = parsed;
      }

      await this.writeConfiguration(
        configContents,
        configRoot,
        configDiagnostics,
        errorRange,
        token,
      );
    }

    /**
     * Calls {@link updateImportsOnly()} after computing ranges from the given
     * JSON node.
     */
    private updateImportsOnlyFromJson(
      contents: string,
      importsNode: Node,
      expectedImports: readonly string[] | undefined,
      diagnostics: readonly vscode.Diagnostic[],
    ): boolean {
      // Compute ranges of imports.
      const importsNodeRange = convertRange(
        contents,
        importsNode.offset,
        importsNode.length,
      );
      const importsWithRanges = getJsonImports(contents, importsNode);

      return this.updateImportsOnly(
        importsWithRanges,
        expectedImports,
        diagnostics,
        importsNodeRange,
      );
    }

    /**
     * Updates the current imports. If the current file is a root file and has
     * no imports as a result of this operation, it will be disposed and this
     * function will return `true`.
     */
    private updateImportsOnly(
      importsWithRanges: readonly [string, vscode.Range][],
      expectedImports: readonly string[] | undefined,
      diagnostics: readonly vscode.Diagnostic[],
      errorRange: vscode.Range,
    ): boolean {
      if (expectedImports !== undefined) {
        // Make sure that the parsed imports correspond to the expected ones.
        if (
          importsWithRanges.length !== expectedImports.length ||
          importsWithRanges.some(([importPath], i) =>
            importPath !== expectedImports[i]
          )
        ) {
          this.setDiagnostics([
            new vscode.Diagnostic(errorRange, IMPORTS_MISMATCH_ERROR),
            ...diagnostics,
          ]);

          return false;
        }
      }

      // Update the imports.
      const importedBefore = new Set(this.imports.map(([f]) => f));

      this.imports.splice(
        0,
        this.imports.length,
        ...importsWithRanges.map(([importPath, range]) =>
          [
            ConfigurationFile.imported(this.resolve(importPath)),
            range,
          ] as const
        ),
      );

      // Add self to importers of imports.
      for (const [importee] of this.imports) {
        importee.importers.add(this);
        importedBefore.delete(importee);
      }

      // Remove self from importers of removed imports.
      for (const importee of importedBefore) {
        importee.importers.delete(this);

        if (importee.importers.size === 0 && !importee.isRootFile) {
          importee.dispose();
        }
      }

      if (this.isRootFile && this.imports.length === 0) {
        this.dispose();

        return true;
      }

      this.refreshDiagnostics();

      return false;
    }

    /**
     * Reads and parses the underlying config file, returning `undefined` if an
     * error was encountered.
     */
    private async readAndParseJsonFile(
      token: vscode.CancellationToken,
    ): Promise<
      | [contents: string, root: Node, diagnostics: vscode.Diagnostic[]]
      | undefined
    > {
      // Load file.
      const contents = await readFile(this.uri);

      if (contents instanceof Error) {
        this.setImportError(contents.message);

        return;
      }

      if (token.isCancellationRequested) {
        return;
      }

      // Parse file.
      const [root, diagnostics] = parseJsonConfig(contents);

      if (root === undefined) {
        if (diagnostics.length === 0) {
          this.setDiagnostics([
            new vscode.Diagnostic(
              new vscode.Range(0, 0, 0, 0),
              CANNOT_PARSE_FILE_ERROR,
            ),
          ]);
        } else {
          this.setDiagnostics(diagnostics);
        }

        return;
      }

      return [contents, root, diagnostics];
    }

    /**
     * Computes and writes the new configuration to disk.
     */
    private async writeConfiguration(
      contents: string,
      settingsNode: Node,
      diagnostics: readonly vscode.Diagnostic[],
      errorRange: vscode.Range,
      token: vscode.CancellationToken,
    ): Promise<void> {
      if (token.isCancellationRequested) {
        return;
      }

      // Compute configuration properties to insert.
      const generatedContentsStart = GEN_START_COMMENT_RE.exec(contents);
      const generatedContentsEnd = GEN_END_COMMENT_RE.exec(contents);
      const mergedConfig = this.mergeImportedConfigs();

      if (!Array.isArray(mergedConfig)) {
        // Erase properties that already exist.
        const beforeOffset = generatedContentsStart?.index ?? Infinity;
        const afterOffset = generatedContentsEnd?.index ?? 0;

        const rootProperties = new Set(
          settingsNode.children!.map((child) =>
            child.type === "property" && child.children?.length === 2 &&
              child.offset < beforeOffset && child.offset > afterOffset
              ? child.children[0].value as string | undefined
              : undefined
          ),
        );

        for (const prop in mergedConfig) {
          if (prop.startsWith("$") || rootProperties.has(prop)) {
            delete mergedConfig[prop];
          }
        }
      }

      // Compute configuration text.
      let configIndent = /^( +)"/m.exec(contents)?.[1].length ?? 2;

      if (this.isWorkspaceFile) {
        configIndent *= 2;
      }

      const configToInsert = JSON.stringify(
        mergedConfig,
        undefined,
        configIndent,
      ).replace(/^[{\[]\n?|[}\]]$/g, "");

      if (configToInsert === "" && generatedContentsStart === null) {
        this.setDiagnostics(diagnostics);

        return;
      }

      let removalStart: number;
      let removalEnd: number;

      if (generatedContentsStart === null) {
        const insertionPosition = settingsNode.offset + settingsNode.length - 1;

        removalStart = insertionPosition;
        removalEnd = insertionPosition;
      } else {
        if (generatedContentsEnd === null) {
          this.setDiagnostics([
            new vscode.Diagnostic(errorRange, NO_CLOSING_COMMENT_ERROR),
            ...diagnostics,
          ]);

          return;
        }

        removalStart = generatedContentsStart.index;
        removalEnd = generatedContentsEnd.index +
          generatedContentsEnd[0].length;
      }

      // Insert comma if necessary.
      const commaOffset = commaInsertionOffset(contents.slice(0, removalStart));

      if (commaOffset !== -1) {
        // A value is already present, but without a comma. Insert it.
        contents = contents.slice(0, commaOffset) + "," +
          contents.slice(commaOffset);
        removalStart++;
        removalEnd++;
      }

      const fullConfigToInsert = " ".repeat(configIndent) + GEN_START_COMMENT +
        configToInsert + " ".repeat(configIndent) + GEN_END_COMMENT;

      const fullConfigText = contents.slice(0, removalStart) +
        fullConfigToInsert + contents.slice(removalEnd);

      if (contents === fullConfigText) {
        this.setDiagnostics(diagnostics);

        return;
      }

      // Write configuration text to file.
      const writeError = await writeFile(this.uri, fullConfigText);

      if (writeError instanceof Error) {
        this.setDiagnostics([
          new vscode.Diagnostic(errorRange, writeError.message),
          ...diagnostics,
        ]);

        return;
      }

      this.setDiagnostics(diagnostics);
    }

    // #endregion
  }

  registerForAllSettingsValues(context, {
    [`${CONFIG_SECTION}.imports`](
      imports: string[] | undefined,
      configUri: vscode.Uri,
    ): void {
      console.assert(
        configUri.scheme === "file" || configUri.scheme === "vscode-userdata",
      );

      const file = ConfigurationFile.root(configUri);

      file.updateImports(imports ?? []);
    },
    [`${CONFIG_SECTION}.importInto`](
      importInto: { [path: string]: string[] } | undefined,
      configUri: vscode.Uri,
    ): void {
      if (importInto === undefined) {
        // TODO: dispose
        return;
      }

      const root = ConfigurationFile.root(configUri);

      for (const [path, imports] of Object.entries(importInto)) {
        const uri = joinMixed(configUri, "..", path);

        ConfigurationFile.writtenTo(uri).updateImports(imports, root, path);
      }
    },
  });
}

function mergeRootObjects(
  xs: readonly Record<string, unknown>[],
): Record<string, unknown> {
  const result = { ...xs[0] };

  for (let i = 1; i < xs.length; i++) {
    const x = xs[i];

    if (Array.isArray(x)) {
      // TODO: diagnostic
      continue;
    }

    for (const prop in x) {
      const xItem = x[prop];
      const mergeItem = result[prop];

      if (mergeItem === undefined) {
        result[prop] = xItem;

        continue;
      }

      if (Array.isArray(mergeItem) && Array.isArray(xItem)) {
        mergeItem.push(...xItem);
      } else if (Array.isArray(mergeItem)) {
        mergeItem.push(xItem);
      } else if (Array.isArray(xItem)) {
        result[prop] = [mergeItem, ...xItem];
      } else {
        result[prop] = xItem;
      }
    }
  }

  return result;
}

function mergeRootArrays(xs: readonly (object | unknown[])[]): unknown[] {
  return xs.flat(1);
}
